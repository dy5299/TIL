# 이미지 프로세싱

## 이미지 다루기

### 이미지 읽기

```python
cv2.imread('lena.jpg', cv2.IMREAD_COLOR)
```

- `cv2.IMREAD_COLOR` : 이미지 파일을 Color로 읽어들입니다. 투명한 부분은 무시됩니다. Default
- `cv2.IMREAD_GRAYSCALE` : 이미지를 Grayscale로 읽어 들입니다. 실제 이미지 처리시 중간단계로 많이 사용합니다.
- `cv2.IMREAD_UNCHANGED` : 이미지파일을 alpha channel까지 포함하여 읽어 들입니다.

참고) 3개의 flag대신에 1, 0, -1을 사용해도 됩니다.
위의 값은 numpy의 ndarray type입니다. numpy는 python에서 수학적 처리를 위한 모듈로 openCV에서도 많이 사용됩니다.

### 이미지 보기

```python
cv2.imshow('title', imgarray)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

`cv2.waitKey()` 는 keyboard입력을 대기하는 함수로 0이면 key입력까지 무한대기이며 특정 시간동안 대기하려면 milisecond값을 넣어주면 됩니다.

`cv2.destroyAllWindows()` 는 화면에 나타난 윈도우를 종료합니다. 일반적으로 위 3개는 같이 사용됩니다.

* Matplotlib 사용

```python
from matplotlib import pyplot as plt
cv2.imread('lena.jpg', cv2.IMREAD_COLOR)
plt.imshow(img)
plt.xticks([]) # x축 눈금
plt.yticks([]) # y축 눈금
plt.show()
```

### 이미지 저장

```python
cv2.imwrite('filename.png', imgarray)
```

### BGR to RGB

```python
import cv2
from matplotlib import pyplot as plt

img = cv2.imread('lena.jpg', cv2.IMREAD_COLOR)

b, g, r = cv2.split(img)
img2 = cv2.merge([r,g,b])

plt.imshow(img2)
plt.show()
```

## 영상 다루기



```python

```




```python

```



```python

```




```python

```

## 도형 그리기



```python
# Line 그리기
cv2.line(img, start, end, color, thickness)
cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)

# 사각형 그리기
cv2.rectangle(img, start, end, color, thickness)
cv2.rectangle(img, (384, 0), (510, 128), (0,255,0), 3)

# 원 그리기
cv2.circle(img, center, radian, color, thickness)
img = cv2.circle(img, (447,63), 63, (0,0,255), -1)

# 타원 그리기
cv2.ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]])
cv2.ellipse(img, (256,256), (100,50), 0, 0, 180, 255, -1)

# polygon 그리기
cv2.polylines(img, pts, isClosed, color, thickness)
pts = np.array([[10,5], [20,30], [70,20], [50,10]], np.int32) # 각 꼭지점은 2차원 행렬로 선언
# 이미지에 표현하기 위해 3차원 행렬로 변환. 변환이전과 이후의 행렬 갯수는 동일해야함.
# -1은 원본에 해당하는 값을 그대로 유지.
pts = pts.reshape((-1, 1, 2))
img = cv2.polylines(img, [pts], True, (0,255,255))
```

* 이미지에 Text 추가


```python
cv2.putText(img, text, org, font, fontSacle, color)
cv2.putText(img, 'OpenCV', (10,500), cv2.FONT_HERSHEY_SIMPLEX, 4, (255,255,255), 2)
```

## Mouse로 그리기



```python

```




```python

```

## Trackbar

```python

```




```python

```

## Basic Operation

ㅇ

```python

```




```python

```



## 이미지 연산





```python

```




```python

```

## 이미지 Processing

Binary Image는 pixel당 1bit로 표현하는 영상을 의미합니다. 즉 흰색과 검은색으로만 표현이 되는 영상입니다.

Grayscale Image는 Pixel당 8bit, 즉 256단계의 명암(빛의 세기)을 표현할 수 있는 이미지입니다.

Color 이미지는 pixel의 색을 표현하기 위해서 pixel당 24bit를 사용합니다. 총 16,777,216 가지의 색을 표현할 수 있습니다. 이것을 일반적으로 True color image라고 합니다. pixel은 RGB 각각을 위해서 8bit를 사용하게 됩니다.



HSV의 의미는 다음과 같습니다.

- H(ue) : 색상. 일반적인 색을 의미함. 원추모형에서 각도로 표현이 됨.(0: Red, 120도 : Green, 240: Blue)
- S(aturation) : 채도. 색읜 순수성을 의미하며 일반적으로 짙다, 흐리다로 표현이 됨. 중심에서 바깥쪽으로 이동하면 채도가 높음.
- V(alue) : 명도. 색의 밝고 어두운 정도. 수직축의 깊이로 표현. 어둡다 밝다로 표현이 됨.

### Color-space 변환

```python
cv2.cvtColor(imgarray, cv2.COLOR_BGR2RGB)
cv2.cvtColor(imgarray, cv2.COLOR_BGR2GRAY)
cv2.cvtColor(imgarray, cv2.COLOR_BGR2HSV)
```

참고) Hue는 [0,179], Saturation은 [0,255], Value는 [0,255]로 표현이 됩니다.

### inRange


```python
lower_blue = np.array([110, 50, 50])
upper_blue = np.array([130, 255, 255])
mask = cv2.inRange(hsv, lower, upper)
```

# 이미지 임계처리

## 기본 임계처리

```python
cv2.threshold(src, thresh, maxval, type) → retval, dst
_, thresh1 = cv2.threshold(img,127,255, cv2.THRESH_BINARY)
```

- **src** – input image로 single-channel 이미지.(grayscale 이미지)
- **thresh** – 임계값
- **maxval** – 임계값을 넘었을 때 적용할 value
- **type** – thresholding type
  - cv2.THRESH_BINARY
  - cv2.THRESH_BINARY_INV
  - cv2.THRESH_TRUNC
  - cv2.THRESH_TOZERO
  - cv2.THRESH_TOZERO_INV

* (참고) 여러 이미지를 하나의 화면에 보여줄때 `plt.subplot()` 함수를 사용합니다.


```python
for i in xrange(6):
    plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')
```

## 적응 임계처리

이전에는 임계값을 이미지 전체에 적용하여 처리하기 때문에 하나의 이미지에 음영이 다르면 일부 영역이 모두 흰색 또는 검정색으로 보여지게 됩니다.

이런 문제를 해결하기 위해서 이미지의 작은 영역별로 thresholding을 하는 것입니다. 이때 사용하는 함수가 `cv2.adaptiveThreshold()` 입니다.

```python
cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)
```

- **src** – grayscale image
- **maxValue** – 임계값
- **adaptiveMethod** – thresholding value를 결정하는 계산 방법
  - cv2.ADAPTIVE_THRESH_MEAN_C : X, Y를 중심으로 block Size * block Size 안에 있는 픽셀 값의 평균에서 C를 뺸 값을 문턱값으로 함
  - cv2.ADAPTIVE_THRESH_GAUSSIAN_C : X, Y를 중심으로 block Size * block Size 안에 있는 Gaussian 윈도우 기반 가중치들의 합에서 C를 뺀 값을 문턱값으로 한다.
- **thresholdType** – threshold type
- **blockSize** – thresholding을 적용할 영역 사이즈
- **C** – 평균이나 가중평균에서 차감할 값

## Otsu의 이진화

임계값을 어떻게 정의해야 할까요? 가장 일반적인 방법은 trial and error방식으로 결정했습니다. 그러나 **bimodal image** (히스토그램으로 분석하면 2개의 peak가 있는 이미지)의 경우는 히스토그램에서 임계값을 어느정도 정확히 계산 할 수 있습니다. Otsu의 이진화(Otsu’s Binarization)란 bimodal image에서 임계값을 자동으로 계산해주는 것을 말합니다.

적용 방법은 `cv2.threshold()` 함수의 flag에 추가로 `cv2.THRESH_STSU` 를 적용하면 됩니다. 이때 임계값은 0으로 전달하면 됩니다.


```python
_, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
```

# 이미지의 기하학적 변형

## Transformations

- 강체변환(Ridid-Body) : 크기 및 각도가 보존(ex; Translation, Rotation)
- 유사변환(Similarity) : 크기는 변하고 각도는 보존(ex; Scaling)
- 선형변환(Linear) : Vector 공간에서의 이동. 이동변환은 제외.
- Affine : 선형변환과 이동변환까지 포함. 선의 수평성은 유지.(ex;사각형->평행사변형)
- Perspective : Affine변환에 수평성도 유지되지 않음. 원근변환

### Scaling

```python

```




```python

```

# Image Smoothing

## Image Filtering

고주파를 제거하면 Blur처리가 되며, 저주파를 제거하면 대상의 영역을 확인할 수 있습니다.

Low-pass filter(LPF)와 High-pass filter(HPF)를 이용하여, LPF를 적용하면 노이즈제거나 blur처리를 할 수 있으며, HPF를 적용하면 경계선을 찾을 수 있습니다.

OpenCV에서는 `cv2.filter2D()` 함수를 이용하여 이미지에 kernel(filter)를 적용하여 이미지를 Filtering할 수 있습니다. kernel은 행렬을 의미하는데 kernel의 크기가 크면 이미지 전체가 blur처리가 많이 됩니다.

Filter가 적용되는 방법은

> - 이미지의 각 pixel에 kernel을 적용합니다.
> - 위 kernel을 예로들면 각 pixel에 5X5윈도우를 올려 놓고, 그 영역안에 포함되는 값의 Sum을 한 후에 25로 나눕니다.
> - 그 결과는 해당 윈도우 영역안의 평균값이 되고, 그 값을 해당 pixel에 적용하는 방식입니다.



## Image Blurring

### Averaging

`cv2.blur()` 또는 `cv2.boxFilter()` 함수로 적용할 수 있습니다.

```python
cv2.blur(src, ksize)
```

### Gaussian Filtering

kernel의 사이즈는 양수이면서 홀수로 지정을 해야 합니다. 이미지의 Gaussian Noise (전체적으로 밀도가 동일한 노이즈, 백색노이즈)를 제거하는 데 가장 효과적입니다.


```python
cv2.GaussianBlur(img, ksize, sigmaX)
```

- **img** – Chennel수는 상관없으나, depth(Data Type)은 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
- **ksize** – (width, height) 형태의 kernel size. width와 height는 서로 다를 수 있지만, 양수의 홀수로 지정해야 함.
- **sigmaX** – Gaussian kernel standard deviation in X direction.

### Median Filtering

중간값을 선택하여 적용합니다. [salt-and-pepper noise](https://ko.wikipedia.org/wiki/점잡음) 제거에 가장 효과적입니다.

```python
cv2.medianBlur(src, ksize)
```

### Bilateral Filtering

Bilateral Filtering(양방향 필터)은 경계선을 유지하면서 Gaussian Blur처리를 해주는 방법입니다.

Gaussian 필터를 적용하고, 또 하나의 Gaussian 필터를 주변 pixel까지 고려하여 적용하는 방식입니다.


```python
cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)
```

- **src** – 8-bit, 1 or 3 Channel image
- **d** – filtering시 고려할 주변 pixel 지름
- **sigmaColor** – Color를 고려할 공간. 숫자가 크면 멀리 있는 색도 고려함.
- **sigmaSpace** – 숫자가 크면 멀리 있는 pixel도 고려함.



* 예제

```python
dst1 = cv2.blur(img,(7,7))
dst2 = cv2.GaussianBlur(img,(5,5),0)
dst3 = cv2.medianBlur(img,9)
dst4 = cv2.bilateralFilter(img,9,75,75)
```

# Morphological Transformations



# Image Gradients



# Image Pyramids



# Image Contours

Contours란 동일한 색 또는 동일한 강도를 가지고 있는 영역의 경계선을 연결한 선입니다.

- 정확도를 높히기 위해서 Binary Image를 사용합니다. threshold나 canny edge를 선처리로 수행합니다.
- `cv2.findContours()` 함수는 원본 이미지를 직접 수정하기 때문에, 원본 이미지를 보존 하려면 Copy해서 사용해야 합니다.
- OpenCV에서는 contours를 찾는 것은 검은색 배경에서 하얀색 대상을 찾는 것과 비슷합니다. 그래서 대상은 흰색, 배경은 검은색으로 해야 합니다.

``` python
cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])
```

- image – 8-bit single-channel image. binary image.

- mode - contours를 찾는 방법

  - `cv2.RETR_EXTERNAL` : contours line중 가장 바같쪽 Line만 찾음.
- `cv2.RETR_LIST` : 모든 contours line을 찾지만, hierachy 관계를 구성하지 않음.
  - `cv2.RETR_CCOMP` : 모든 contours line을 찾으며, hieracy관계는 2-level로 구성함.
- `cv2.RETR_TREE` : 모든 contours line을 찾으며, 모든 hieracy관계를 구성함.
  
- method – contours를 찾을 때 사용하는 근사치 방법

  - `cv2.CHAIN_APPROX_NONE` : 모든 contours point를 저장.
- `cv2.CHAIN_APPROX_SIMPLE` : contours line을 그릴 수 있는 point 만 저장. (ex; 사각형이면 4개 point)
  - `cv2.CHAIN_APPROX_TC89_L1` : contours point를 찾는 algorithm
- `cv2.CHAIN_APPROX_TC89_KCOS` : contours point를 찾는 algorithm

* Returns : image, contours , hierachy

```python
cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])
```

- image – 원본 이미지
- contours – contours정보. list로 들어가야 해
- contourIdx – contours list type에서 몇번째 contours line을 그릴 것인지. -1 이면 전체
- color – contours line color
- thickness – contours line의 두께. 음수이면 contours line의 내부를 채움.

# Contour Feature

* Image Moment는 대상을 구분할 수 있는 특징을 의미합니다.. 특징으로는 Area, Perimeter, 중심점 등이 있습니다. Image Moments는 대상을 구분한 후, 다른 대상과 구분하기 위해 대상을 설명(describe)하는 자료로 사용됩니다.
* Contour면적은 moments의 `m00` 값이거나 `cv2.contourArea()` 함수로 구할 수 있다.

### Contour Perimeter

Contour의 둘레 길이를 구할 수 있습니다. 사각형의 경우는 둘레길이의 합이 됩니다. 아래 함수의 2번째 argument가 true이면 폐곡선 도형을 만들어 둘레길이를 구하고, False이면 시작점과 끝점을 연결하지 않고 둘레 길이를 구합니다.

```python
>>> cv2.arcLength(cnt, True)
750.0
>>> cv2.arcLength(cnt, False)
494.0
```

### Contour Approximation

`cv2.findContours()` 함수에 의해서 찾은 contours line은 각각의 contours point를 가지고 있습니다. 이 Point를 연결하여 Line을 그리게 됩니다. 이때 이 point의 수를 줄여 근사한 line을 그릴 때 사용되는 방법입니다.

Point의 수를 줄이는데 사용되는 방식은 [Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm) 입니다.

근사치를 찾는데 사용되는 함수는 `cv2.approxPolyDP()` 입니다.

```python
cv2.approxPolyDP(curve, epsilon, closed[, approxCurve])
```

- **curve** – contours point array
- **epsilon** – original cuve와 근사치의 최대거리. 최대거리가 클 수록 더 먼 곳의 Point까지 고려하기 때문에 Point수가 줄어듬.
- **closed** – 폐곡선 여부

### Convex Hull

Convex Hull이란 contours point를 모두 포함하는 볼록한 외관선을 의미합니다. Contour Approximation과 유사한 결과지만, 방법은 전혀 다릅니다.

```python
cv2.convexHull(array)
```

### Checking Convexity

`cv2.isContourConvex()` 함수는 contour가 convex인지 아닌지 판단하여 True 또는 False를 Return합니다. 여기서 convex란 contour line이 볼록하거나 최소한 평평한 것을 의미합니다.(오목한 부분이 없는 것입니다.)

위 예제에는 2개의 contour가 있는데, 첫번째는 이미지의 전체 외곽선(사각형)이고 두번째는 손 모양의 contour line입니다. 그래서 결과는 아래와 같습니다.

```
>>> cv2.isContourConvex(contours[0]) # 외곽선 contour line
True
>>> cv2.isContourConvex(contours[1]) # 손 모양 contour line
False
```







### Bounding Rectangle

Contours Line을 둘러싸는 사각형을 그리는 방법입니다. 사각형을 그리는 방법은 2가지가 있습니다.

1. **Straight Bounding Rectangle** : 대상의 Rotation은 무시한 사각형 모양입니다.

```
x,y,w,h = cv2.boundingRect(cnt)
img = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)
```

1. **Rotated Rectangle** : 대상을 모두 포함하면서, 최소한의 영역을 차지하는 사각형 모양입니다.

```
rect = cv2.minAreaRect(cnt)
box = cv2.boxPoints(rect)
box = np.int0(box)
im = cv2.drawContours(im,[box],0,(0,0,255),2)
```

### Minumum Enclosing Circle

Contours line을 완전히 포함하는 원 중 가장 작은 원을 그릴 수 있습니다.

```
(x,y),radius = cv2.minEnclosingCircle(cnt)
center = (int(x),int(y))
radius = int(radius)
img = cv2.circle(img,center,radius,(0,255,0),2)
```

### Fitting an Ellipse

Contours Line을 둘러싸는 타원을 그릴 수 있습니다.

```
ellipse = cv2.fitEllipse(cnt)
im = cv2.ellipse(im,ellipse,(0,255,0),2)
```

# Contour Property



# Morphology

영상을 형태학적 관점에서 보고 접근하는 방법

영상내에 존재하는 특정 객체의 형태를 변형시키는 용도로 사용되는 영상처리기법

* 이진영상처리에 주로 사용됨

* 집합의 포함관계,이동,대칭,여집합,차집합 등을 이용함

* 영상에서 잡음을 제거하거나 ,영상에서 객체의 모양을 기술하는 용도로 사용됨
  예: 모폴로지의 대표적인 예로 침식과 팽창연산이있음
* 고수준 모폴로지 를 적용하려면 morphologyEx 함수를 이용

## Erode, Dilate

필터 내부의 가장 낮은(어두운) 값으로 변환(and) - 침식연산

* 바이너리 이미지에서 흰색 오브젝트의 외곽 픽셀을 0(검은색)으로 만듭니다. 
* Foreground 가 되는 이미지의 경계부분을 침식시켜서 Background 이미지로 전환한다.
* Foreground 이미지가 가늘게 된다.
* 흐릿한 경계부분은 배경으로 만들어버린다고 생각

```py
erosion = cv2.erode(img, kernel, iterations=1)
```

필터 크기를 크게 할 수록 변화량이 많아진다.

사용한 커널의 크기에 따라  오브젝트 외곽에서 0이 되는 픽셀의 정도가 달라집니다. 

iterations : 반복 수행 횟수

3번째 인자는 mask의 중심점인데 default로 -1,-1이 들어간다. 

## Dilate

필터 내부의 가장 높은(밝은) 값으로 변환(or) - 팽창연산

* 바이너리 이미지에서 흰색 오브젝트의 외곽 픽셀 주변에 1(흰색)으로 추가합니다. 
* 노이즈(작은 흰색 오브젝트)를 없애기 위해 사용한 Erosion에 의해서 작아졌던 오브젝트를 원래대로 돌리거나 인접해 있는 오브젝트들을 하나로 만드는데 사용할 수 있습니다. 

## Opening

두 연산은 순서에 따라 서로 다른 기능을 한다. 

* Erode - Dilate
*  `cv2.MORPH_OPEN`

* 이미지 상의 노이즈(작은 흰색 물체)를 제거하는데 사용합니다. 

```python
kernel = np.ones((5, 5), np.uint8)
result = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
```

```python
opened = cv2.cv2.morphologyEx(binary, cv2.MORPH_OPEN,
            cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5)), iterations=5)
```

## Closing

* Dilate - Erode
* `cv2.MORPH_CLOSE`

* 보통 한 객체를 추출했을 때 두개 이상의 작은 부분으로 나올 경우 큰 객체로 합칠 때 사용한다. 
* 희색 오브젝트에 있는 작은 검은색 구멍들을 메우는데 사용합니다.

```python
closed = cv2.cv2.morphologyEx(binary, cv2.MORPH_CLOSE,
            cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5)), iterations=5)
```



https://webnautes.tistory.com/1257



로우레벨비전
엣지 찾는게 아니라
텍스트 찾기